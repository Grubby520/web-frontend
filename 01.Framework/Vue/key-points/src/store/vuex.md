### 设计思想
我们继续延伸约定，组件不允许直接变更属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 变更，同时实现能做到记录变更、保存状态快照、历史回滚/时光旅行的先进的调试工具。

### Vuex vs 单纯的全局对象
1、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

2、你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，保存状态快照，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

### 组件中使用vuex的场景
kp1:
多个组件共享状态的时候，单向数据流就很容易被破坏 vs 单向数据流
（产品模块，多个组件内部都可以更新产品信息，其他视图需响应式的更新视图）
 1.多个视图依赖同一个状态；
 2.不同视图的行为需要更新同一个状态；
kp2:
全局单例模式 vs vuex ?
优势：通过定义和隔离状态管理中的各种概念并通过<强制规则>维持<视图和状态间的独立性>，我们的代码将会变得更<结构化>且易维护。
kp3:
专门为vue.js设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。
借鉴思想：Flux, Redux;

### 难点
(1) ? 单状态树和模块化并不冲突
在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中;

